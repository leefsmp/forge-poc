{"version":3,"sources":["components/Viewer.Components/Extensions/Dynamic/Viewing.Extension.PointCloudMarkup/PointCloudMarkup/index.js","components/Viewer.Components/Extensions/Dynamic/Viewing.Extension.PointCloudMarkup/PointCloudMarkup/texture.png","components/Viewer.Components/Extensions/Dynamic/Viewing.Extension.PointCloudMarkup/PointCloudMarkup/PointCloudMarkup.js"],"names":["__webpack_require__","r","__webpack_exports__","_PointCloudMarkup__WEBPACK_IMPORTED_MODULE_0__","PointCloudMarkup","module","exports","p","viewer","_this","options","arguments","length","undefined","Object","_Users_philippe_Dropbox_projects_leefsmp_forge_poc_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","this","_Users_philippe_Dropbox_projects_leefsmp_forge_poc_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__","_Users_philippe_Dropbox_projects_leefsmp_forge_poc_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__","call","onCameraChanged","bind","_Users_philippe_Dropbox_projects_leefsmp_forge_poc_node_modules_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__","onVisibility","onExplode","dbIds","getAllDbIds","eventHandlers","event","Autodesk","Viewing","EXPLODE_CHANGE_EVENT","handler","CAMERA_CHANGE_EVENT","ISOLATE_EVENT","HIDE_EVENT","SHOW_EVENT","forEach","entry","addEventListener","geometry","THREE","Geometry","maxPoints","i","vertices","push","Vector3","shader","createShader","pointCloud","PointCloud","material","frustumCulled","impl","sceneAfter","add","markups","vertexShader","fragmentShader","tex","texture","defaultTex","shaderParams","side","DoubleSide","depthWrite","depthTest","opacity","attributes","pointSize","type","value","color","uniforms","ImageUtils","loadTexture","ShaderMaterial","stopwatch","Stopwatch","radius","setTexture","needsUpdate","update","dt","getElapsedMs","size","pixels","u","v","dist","Math","sqrt","dataTexture","DataTexture","Uint8Array","from","RGBAFormat","UnsignedByteType","UVMapping","minFilter","NearestFilter","magFilter","generateTexture","_this2","markup","setMarkupColor","id","invalidate","runAnimation","_this3","Vector4","t","markupId","res","filter","override","getMarkupById","visible","__visible","index","occlusion","checkOcclusion","clr","fragId","mesh","getRenderProxy","model","pos","setFromMatrixPosition","matrixWorld","markupInfo","markupSize","assign","initialFragPos","getFragmentPos","name","guid","vertex","x","point","y","z","verticesNeedUpdate","setMarkupSize","updateMarkup","emit","_this4","idx","data","occluded","_this5","state","clearMarkups","addMarkup","_this6","_this7","fragPos","setMarkupPosition","_this8","nodeIdArray","indexOf","dbId","__setMarkupVisibility","domElement","camera","pointerVector","pointerDir","ray","Raycaster","params","threshold","selectionRayThreshold","rect","getBoundingClientRect","left","width","top","height","isPerspective","set","unproject","position","sub","normalize","transformDirection","screenPoint","selectionDistThreshold","pointToRaycaster","canvas","intersectObjects","diff","clientPoint","worldToClient","offset","$","container","rayCaster","hitTest","rayIntersect","logOcclusionDist","console","log","occlusionDist","dbIdToIndex","getData","instanceTree","nodeAccess","keys","map","parseInt","_this9","remove","removeEventListener","off","EventsEmitter"],"mappings":"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","file":"static/js/18.f39d9bd0.chunk.js","sourcesContent":["import PointCloudMarkup from './PointCloudMarkup'\n\nexport default PointCloudMarkup\n","module.exports = __webpack_public_path__ + \"a91f7a1f684a8cae1c93a3e15fda6826.png\";","///////////////////////////////////////////////////////////\n// PointCloudMarkup: high-perf markup 3D for Forge Viewer\n// by Philippe Leefsma, December 2017\n//\n///////////////////////////////////////////////////////////\nimport EventsEmitter from 'EventsEmitter'\nimport defaultTex from './texture.png'\nimport Stopwatch from 'Stopwatch'\n\nexport default class PointCloudMarkup extends EventsEmitter {\n\n  /////////////////////////////////////////////////////////\n  //\n  //\n  /////////////////////////////////////////////////////////\n  constructor (viewer, options = {}) {\n\n    super()\n\n    this.onCameraChanged = this.onCameraChanged.bind(this)\n    this.onVisibility = this.onVisibility.bind(this)\n    this.onExplode = this.onExplode.bind(this)\n\n    this.viewer = viewer\n\n    this.dbIds = this.getAllDbIds()\n\n    this.eventHandlers = [{\n        event: Autodesk.Viewing.EXPLODE_CHANGE_EVENT,\n        handler: this.onExplode\n      }, {\n        event: Autodesk.Viewing.CAMERA_CHANGE_EVENT,\n        handler: this.onCameraChanged\n      }, {\n        event: Autodesk.Viewing.ISOLATE_EVENT,\n        handler: this.onVisibility\n      }, {\n        event: Autodesk.Viewing.HIDE_EVENT,\n        handler: this.onVisibility\n      }, {\n        event: Autodesk.Viewing.SHOW_EVENT,\n        handler: this.onVisibility\n      }]\n\n    this.eventHandlers.forEach((entry) => {\n\n      this.viewer.addEventListener(\n        entry.event, entry.handler)\n    })\n\n    // Initialize geometry vertices\n    // and shader attribute colors\n    this.geometry = new THREE.Geometry()\n\n    const maxPoints = options.maxPoints || 10000\n\n    for (var i = 0; i < maxPoints; ++i) {\n\n      this.geometry.vertices.push(new THREE.Vector3)\n    }\n\n    this.shader = this.createShader(options)\n\n    // creates THREE.PointCloud\n    this.pointCloud = new THREE.PointCloud(\n      this.geometry, this.shader.material)\n\n    this.pointCloud.frustumCulled = false\n\n    // adds to the viewer scene\n    this.viewer.impl.sceneAfter.add(this.pointCloud)\n\n    //this.update = throttle(this.update, 10)\n\n    this.options = options\n\n    this.markups = []\n  }\n\n  /////////////////////////////////////////////////////////\n  // Generates custom shader using an updatable\n  // dynamic texture generated programmatically\n  //\n  /////////////////////////////////////////////////////////\n  createShader (options) {\n\n    // Vertex Shader code\n    const vertexShader = options.vertexShader || `\n      attribute float pointSize;\n      attribute vec4 color;\n      varying vec4 vColor;\n      void main() {\n        vec4 vPosition = modelViewMatrix * vec4(position, 1.0);\n        gl_Position = projectionMatrix * vPosition;\n        gl_PointSize = pointSize;\n        vColor = color;\n      }\n    `\n\n    // Fragment Shader code\n    const fragmentShader = options.fragmentShader || `\n      uniform sampler2D texture;\n      varying vec4 vColor;\n      void main() {\n        vec4 tex = texture2D(texture, gl_PointCoord);\n        if (tex.a < 0.2) discard;\n        if (vColor.a == 0.0) {\n          gl_FragColor = vec4(tex.r, tex.g, tex.b, tex.a);\n        } else {\n          gl_FragColor = vColor;\n        }\n      }\n    `\n\n    const tex = options.texture || defaultTex\n\n    // Shader material parameters\n    const shaderParams = options.shaderParams || {\n        side: THREE.DoubleSide,\n        depthWrite: false,\n        depthTest: false,\n        fragmentShader,\n        vertexShader,\n        opacity: 0.5,\n        attributes: {\n          pointSize: {\n            type: 'f',\n            value: []\n          },\n          color: {\n            type: 'v4',\n            value: []\n          }\n        },\n        uniforms: {\n          texture: {\n            value: THREE.ImageUtils.loadTexture(tex),\n            type: 't'\n          }\n        }\n      }\n\n    // creates shader material\n    const material =\n      new THREE.ShaderMaterial(\n        shaderParams)\n\n    const generateTexture = (size, radius) => {\n\n      const pixels = []\n\n      for (let u = 0; u < size; ++u) {\n\n        for (let v = 0; v < size ; ++v) {\n\n          const dist = Math.sqrt(\n            (u/size - 0.5) * (u/size - 0.5) +\n            (v/size - 0.5) * (v/size - 0.5))\n\n         if (dist < 0.1) {\n\n           pixels.push(0xff, 0x00, 0x00, 0xff)\n\n         } else if (dist < (radius - 0.05)) {\n\n            pixels.push(0xff, 0x00, 0x00, 0x00)\n\n          } else if (dist < radius) {\n\n            pixels.push(0xff, 0x00, 0x00, 0xff)\n\n          } else {\n\n            pixels.push(0x00, 0x00, 0x00, 0x00)\n          }\n        }\n      }\n\n      const dataTexture = new THREE.DataTexture (\n        Uint8Array.from (pixels),\n        size, size,\n        THREE.RGBAFormat,\n        THREE.UnsignedByteType,\n        THREE.UVMapping\n      )\n\n      dataTexture.minFilter = THREE.NearestFilter\n      dataTexture.magFilter = THREE.NearestFilter\n      dataTexture.needsUpdate = true\n\n      return dataTexture\n    }\n\n    const generateCanvasTexture = () => {\n\n      const canvas = document.createElement(\"canvas\")\n      const ctx = canvas.getContext('2d')\n\n      ctx.font = '20pt Arial'\n      ctx.textAlign = 'center'\n      ctx.textBaseline = 'middle'\n      ctx.fillText(new Date().toLocaleString(),\n        canvas.width / 2, canvas.height / 2)\n\n      const canvasTexture = new THREE.Texture(canvas)\n\n      canvasTexture.needsUpdate = true\n      canvasTexture.flipX = false\n      canvasTexture.flipY = false\n\n      return canvasTexture\n    }\n\n    const stopwatch = new Stopwatch()\n\n    let radius = 0.0\n\n    return {\n      setTexture: (tex) => {\n\n        const {texture} = shaderParams.uniforms\n\n        texture.value = THREE.ImageUtils.loadTexture(tex)\n\n        texture.needsUpdate = true\n\n      },\n      update: () => {\n\n        const dt = stopwatch.getElapsedMs() * 0.001\n\n        radius += dt * 0.25\n\n        radius = radius > 0.5 ? 0.0 : radius\n\n        const {texture} = shaderParams.uniforms\n\n        //texture.value = generateCanvasTexture()\n        texture.value = generateTexture(96, radius)\n\n        texture.needsUpdate = true\n      },\n      material\n    }\n  }\n\n  /////////////////////////////////////////////////////////\n  //\n  //\n  /////////////////////////////////////////////////////////\n  startAnimation () {\n\n    this.markups.forEach((markup) => {\n\n      this.setMarkupColor (markup.id,\n        markup.color)\n    })\n\n    this.viewer.impl.invalidate (true)\n\n    this.runAnimation = true\n  }\n\n  /////////////////////////////////////////////////////////\n  //\n  //\n  /////////////////////////////////////////////////////////\n  stopAnimation () {\n\n    const texture = this.options.texture || defaultTex\n\n    this.shader.setTexture(texture)\n\n    this.markups.forEach((markup) => {\n\n      this.setMarkupColor (markup.id,\n        new THREE.Vector4(0,0,0,0),\n        true)\n    })\n\n    this.viewer.impl.invalidate (true)\n\n    this.runAnimation = false\n  }\n\n  /////////////////////////////////////////////////////////\n  //\n  //\n  /////////////////////////////////////////////////////////\n  update (t) {\n\n    this.shader.update(t)\n\n    this.viewer.impl.invalidate (false, true, false)\n  }\n\n  /////////////////////////////////////////////////////////\n  // Returns markup from markupId\n  //\n  /////////////////////////////////////////////////////////\n  getMarkupById (markupId) {\n\n    const res = this.markups.filter((markup) => {\n\n      return markup.id === markupId\n    })\n\n    return res.length ? res[0] : null\n  }\n\n  /////////////////////////////////////////////////////////\n  // Set markup size\n  //\n  /////////////////////////////////////////////////////////\n  setMarkupSize (markupId, size, override) {\n\n    const {pointSize} = this.pointCloud.material.attributes\n\n    const markup = this.getMarkupById(markupId)\n\n    const visible = markup.visible && markup.__visible\n\n    if (override) {\n\n      pointSize.value[markup.index] = size\n\n    } else if (visible) {\n\n      if (markup.occlusion) {\n\n        if (!this.checkOcclusion(markup)) {\n\n          pointSize.value[markup.index] = size\n        }\n\n      } else {\n\n        pointSize.value[markup.index] = size\n      }\n    }\n\n    markup.size = !override ? size : markup.size\n\n    pointSize.needsUpdate = true\n\n    this.viewer.impl.invalidate (true)\n  }\n\n  /////////////////////////////////////////////////////////\n  // Set markup color\n  //\n  /////////////////////////////////////////////////////////\n  setMarkupColor (markupId, clr, override) {\n\n    const {color} = this.pointCloud.material.attributes\n\n    const markup = this.getMarkupById(markupId)\n\n    color.value[markup.index] = clr\n\n    markup.color = !override ? clr : markup.color\n\n    color.needsUpdate = true\n\n    this.viewer.impl.invalidate (true)\n  }\n\n  /////////////////////////////////////////////////////////\n  // Adds new markup\n  //\n  /////////////////////////////////////////////////////////\n  getFragmentPos (fragId) {\n\n    const mesh = this.viewer.impl.getRenderProxy(\n      this.viewer.model, fragId)\n\n    const pos = new THREE.Vector3()\n\n    pos.setFromMatrixPosition(mesh.matrixWorld)\n\n    return pos\n  }\n\n  /////////////////////////////////////////////////////////\n  // Adds new markup\n  //\n  /////////////////////////////////////////////////////////\n  addMarkup (markupInfo) {\n\n    const size = markupInfo.size ||\n      this.options.markupSize ||\n      40\n\n    const index = this.markups.length\n\n    const markup = Object.assign({}, {\n      initialFragPos: this.getFragmentPos(markupInfo.fragId),\n      color: new THREE.Vector4(1,0,0,1),\n      name: 'Markup ' + (index + 1),\n      id: this.guid('xxx-xxx-xxx'),\n      __visible: true,\n      occlusion: true,\n      visible: true,\n      size\n    }, markupInfo, {\n      index\n    })\n\n    const vertex = this.geometry.vertices[markup.index]\n\n    vertex.x = markup.point.x\n    vertex.y = markup.point.y\n    vertex.z = markup.point.z\n\n    this.geometry.verticesNeedUpdate = true\n\n    this.markups.push(markup)\n\n    this.setMarkupSize (\n      markup.id, markup.size)\n\n    this.updateMarkup (markup)\n\n    this.setMarkupColor (\n      markup.id,\n      this.runAnimation\n        ? markup.color\n        : new THREE.Vector4(0,0,0,0),\n      !this.runAnimation)\n\n    this.emit('markup.created', markup)\n\n    return markup\n  }\n\n  /////////////////////////////////////////////////////////\n  // Removes markup\n  //\n  /////////////////////////////////////////////////////////\n  removeMarkup (markupId) {\n\n    const {pointSize} = this.pointCloud.material.attributes\n\n    this.markups = this.markups.filter((markup) => {\n\n        return (markup.id !== markupId)\n    })\n\n    this.markups.forEach((markup, idx) => {\n\n      const vertex = this.geometry.vertices[idx]\n\n      pointSize.value[idx] = markup.size\n\n      vertex.x = markup.point.x\n      vertex.y = markup.point.y\n      vertex.z = markup.point.z\n\n      markup.index = idx\n\n      this.updateMarkup (markup)\n    })\n\n    for (let idx = this.markups.length;\n             idx < this.geometry.vertices.length; ++idx) {\n\n      pointSize.value[idx] = 0.0\n    }\n\n    this.geometry.verticesNeedUpdate = true\n\n    pointSize.needsUpdate = true\n\n    this.viewer.impl.invalidate(true)\n\n    this.emit('markup.deleted',\n      markupId)\n  }\n\n  /////////////////////////////////////////////////////////\n  // Clear all markups\n  //\n  /////////////////////////////////////////////////////////\n  clearMarkups () {\n\n    const {pointSize} = this.pointCloud.material.attributes\n\n    const {length} = this.geometry.vertices\n\n    for (let idx = 0; idx < length; ++idx) {\n\n      pointSize.value[idx] = 0.0\n    }\n\n    pointSize.needsUpdate = true\n\n    this.viewer.impl.invalidate (true)\n\n    this.markups = []\n  }\n\n  /////////////////////////////////////////////////////////\n  // Set markup position\n  //\n  /////////////////////////////////////////////////////////\n  setMarkupPosition (markupId, point) {\n\n    const markup = this.getMarkupById(markupId)\n\n    const vertex = this.geometry.vertices[markup.index]\n\n    vertex.x = point.x\n    vertex.y = point.y\n    vertex.z = point.z\n\n    this.geometry.verticesNeedUpdate = true\n  }\n\n  /////////////////////////////////////////////////////////\n  // Set markup data\n  //\n  /////////////////////////////////////////////////////////\n  setMarkupData (markupId, data) {\n\n    const markup = this.getMarkupById(markupId)\n\n    Object.assign(markup, data)\n  }\n\n  /////////////////////////////////////////////////////////\n  // Set markup visibility: to hide markup, set size to 0\n  //\n  /////////////////////////////////////////////////////////\n  setMarkupVisibility (markupId, visible) {\n\n    const markup = this.getMarkupById(markupId)\n\n    markup.visible = visible\n\n    this.updateMarkup (markup)\n  }\n\n  /////////////////////////////////////////////////////////\n  // Set markup visibility internal\n  //\n  /////////////////////////////////////////////////////////\n  __setMarkupVisibility (markupId, __visible) {\n\n    const markup = this.getMarkupById(markupId)\n\n    markup.__visible = __visible\n\n    this.updateMarkup (markup)\n  }\n\n  /////////////////////////////////////////////////////////\n  // Set markup occlusion property\n  //\n  /////////////////////////////////////////////////////////\n  setMarkupOcclusion (markupId, occlusion) {\n\n    const markup = this.getMarkupById(markupId)\n\n    markup.occlusion = occlusion\n\n    this.updateMarkup (markup)\n  }\n\n  /////////////////////////////////////////////////////////\n  // Update markup\n  //\n  /////////////////////////////////////////////////////////\n  updateMarkup (markup) {\n\n    const visible = markup.visible && markup.__visible\n\n    if (visible) {\n\n      if (markup.occlusion) {\n\n        const occluded = this.checkOcclusion(markup)\n\n        this.setMarkupSize (markup.id,\n          occluded ? 0.0 : markup.size,\n          true)\n\n      } else {\n\n        this.setMarkupSize (markup.id,\n          markup.size,\n          true)\n      }\n\n    } else {\n\n      this.setMarkupSize (markup.id,\n        0.0, true)\n    }\n  }\n\n  /////////////////////////////////////////////////////////\n  // Get markups state\n  //\n  /////////////////////////////////////////////////////////\n  getState () {\n\n    return {\n      markups: this.markups\n    }\n  }\n\n  /////////////////////////////////////////////////////////\n  // Restore state\n  //\n  /////////////////////////////////////////////////////////\n  restoreState (state = {}) {\n\n    this.clearMarkups()\n\n    if (state.markups) {\n\n      state.markups.forEach((markup) => {\n\n        this.addMarkup(markup)\n      })\n    }\n  }\n\n  /////////////////////////////////////////////////////////\n  // Camera Changed event handler\n  //\n  /////////////////////////////////////////////////////////\n  onCameraChanged (event) {\n\n    this.markups.forEach((markup) => {\n\n      const visible = markup.visible && markup.__visible\n\n      if (visible && markup.occlusion) {\n\n        const occluded = this.checkOcclusion(markup)\n\n        this.setMarkupSize (markup.id,\n          occluded ? 0.0 : markup.size,\n          true)\n      }\n    })\n  }\n\n  /////////////////////////////////////////////////////////\n  // Explode event handler\n  //\n  /////////////////////////////////////////////////////////\n  onExplode (event) {\n\n    this.markups.forEach((markup) => {\n\n      const visible = markup.visible && markup.__visible\n\n      if (visible) {\n\n        const fragPos = this.getFragmentPos(markup.fragId)\n\n        const {point, initialFragPos} = markup\n\n        const pos = {\n          x: point.x + fragPos.x - initialFragPos.x,\n          y: point.y + fragPos.y - initialFragPos.y,\n          z: point.z + fragPos.z - initialFragPos.z\n        }\n\n        this.setMarkupPosition(markup.id, pos)\n      }\n    })\n  }\n\n  /////////////////////////////////////////////////////////\n  // Visibility Changed event handler\n  //\n  /////////////////////////////////////////////////////////\n  onVisibility (event) {\n\n    this.markups.forEach((markup) => {\n\n      const dbIds = event.nodeIdArray\n\n      switch (event.type) {\n\n        case 'isolate':\n\n          // if this node is isolated or all nodes visible\n          if (dbIds.indexOf(markup.dbId) > -1 || !dbIds.length) {\n\n            this.__setMarkupVisibility(markup.id, true)\n\n            // if another node is isolated\n          } else if (dbIds.length) {\n\n            this.__setMarkupVisibility(markup.id, false)\n          }\n\n          break\n\n        case 'hide':\n\n          // this node is hidden\n          if (dbIds.indexOf(markup.dbId) > -1) {\n\n            this.__setMarkupVisibility(markup.id, false)\n          }\n\n          break\n\n        case 'show':\n\n          // this node is shown\n          if (dbIds.indexOf(markup.dbId) > -1) {\n\n            this.__setMarkupVisibility(markup.id, true)\n          }\n\n          break\n      }\n    })\n  }\n\n  /////////////////////////////////////////////////////////\n  // Creates Raycaster object from client point\n  //\n  /////////////////////////////////////////////////////////\n  pointToRaycaster (domElement, camera, point) {\n\n    const pointerVector = new THREE.Vector3()\n    const pointerDir = new THREE.Vector3()\n    const ray = new THREE.Raycaster()\n\n    ray.params.PointCloud.threshold = \n      this.options.selectionRayThreshold ||\n      1.0\n\n    const rect = domElement.getBoundingClientRect()\n\n    const x =  ((point.x - rect.left) / rect.width)  * 2 - 1\n    const y = -((point.y - rect.top)  / rect.height) * 2 + 1\n\n    if (camera.isPerspective) {\n\n      pointerVector.set(x, y, 0.5)\n\n      pointerVector.unproject(camera)\n\n      ray.set(camera.position,\n        pointerVector.sub(\n          camera.position).normalize())\n\n    } else {\n\n      pointerVector.set(x, y, -1)\n\n      pointerVector.unproject(camera)\n\n      pointerDir.set(0, 0, -1)\n\n      ray.set(pointerVector,\n        pointerDir.transformDirection(\n          camera.matrixWorld))\n    }\n\n    return ray\n  }\n\n  /////////////////////////////////////////////////////////\n  // Returns array of selected markups for given screenPoint\n  //\n  /////////////////////////////////////////////////////////\n  getSelection (screenPoint, \n    threshold = this.options.selectionDistThreshold || 1.0) {\n\n    const rayCaster = this.pointToRaycaster(\n      this.viewer.impl.canvas,\n      this.viewer.impl.camera, {\n        x: screenPoint.x,\n        y: screenPoint.y\n      })\n\n    const res = rayCaster.intersectObjects(\n      [this.pointCloud], true)\n\n    if (res.length) {\n\n      return this.markups.filter((markup) => {\n\n        const diff = {\n          x: res[0].point.x - markup.point.x,\n          y: res[0].point.y - markup.point.y,\n          z: res[0].point.z - markup.point.z\n        }\n\n        const dist = Math.sqrt(\n          diff.x * diff.x +\n          diff.y * diff.y +\n          diff.z * diff.z)\n\n        return dist < threshold\n      })\n    }\n\n    return []\n  }\n\n  /////////////////////////////////////////////////////////\n  // Occlusion check: return true if markup\n  // is being occluded\n  //\n  /////////////////////////////////////////////////////////\n  checkOcclusion (markup) {\n\n    const clientPoint = this.viewer.worldToClient(\n      markup.point)\n\n    const offset = $(this.viewer.container).offset()\n\n    const rayCaster = this.pointToRaycaster(\n      this.viewer.impl.canvas,\n      this.viewer.impl.camera, {\n        x: clientPoint.x + offset.left,\n        y: clientPoint.y + offset.top\n      })\n\n    const hitTest = this.viewer.model.rayIntersect(\n      rayCaster, true, this.dbIds)\n\n    if (hitTest) {\n\n      if (hitTest.fragId === markup.fragId) {\n\n        const offset = {\n          x: hitTest.point.x - markup.point.x,\n          y: hitTest.point.y - markup.point.y,\n          z: hitTest.point.z - markup.point.z\n        }\n\n        const dist = Math.sqrt(\n          offset.x * offset.x +\n          offset.y * offset.y +\n          offset.z * offset.z)\n\n        if (this.options.logOcclusionDist) {\n          console.log(dist)\n        }\n\n        if (dist < this.options.occlusionDist) {\n          return false\n        }\n      }\n\n      return true\n    }\n  }\n\n  /////////////////////////////////////////////////////////\n  // Get list of all dbIds in the model\n  //\n  /////////////////////////////////////////////////////////\n  getAllDbIds () {\n\n    const {instanceTree} = this.viewer.model.getData()\n\n    const {dbIdToIndex} = instanceTree.nodeAccess\n\n    return Object.keys(dbIdToIndex).map((dbId) => {\n\n      return parseInt(dbId)\n    })\n  }\n\n  /////////////////////////////////////////////////////////\n  // Removes everything\n  //\n  /////////////////////////////////////////////////////////\n  destroy () {\n\n    this.viewer.impl.sceneAfter.remove(this.pointCloud)\n\n    this.eventHandlers.forEach((entry) => {\n\n      this.viewer.removeEventListener(\n        entry.event, entry.handler)\n    })\n\n    this.runAnimation = false\n\n    this.markups = []\n\n    this.off ()\n  }\n}\n\n\n"],"sourceRoot":""}